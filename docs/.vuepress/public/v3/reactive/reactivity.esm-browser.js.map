{"version":3,"file":"reactivity.esm-browser.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/warning.ts","../src/effectScope.ts","../src/dep.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts","../src/deferredComputed.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport { makeMap }\r\nexport * from './patchFlags'\r\nexport * from './shapeFlags'\r\nexport * from './slotFlags'\r\nexport * from './globalsWhitelist'\r\nexport * from './codeframe'\r\nexport * from './normalizeProp'\r\nexport * from './domTagConfig'\r\nexport * from './domAttrConfig'\r\nexport * from './escapeHtml'\r\nexport * from './looseEqual'\r\nexport * from './toDisplayString'\r\nexport * from './typeUtils'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nconst onRE = /^on[^a-z]/\r\nexport const isOn = (key: string) => onRE.test(key)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date => toTypeString(val) === '[object Date]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as any\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase()\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(\r\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction((str: string) =>\r\n  str ? `on${capitalize(str)}` : ``\r\n)\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\nexport const toNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n        ? self\r\n        : typeof window !== 'undefined'\r\n        ? window\r\n        : typeof global !== 'undefined'\r\n        ? global\r\n        : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n","export function warn(msg: string, ...args: any[]) {\r\n  console.warn(`[Vue warn] ${msg}`, ...args)\r\n}\r\n","import { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(detached = false) {\r\n    if (!detached && activeEffectScope) {\r\n      this.parent = activeEffectScope\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this.active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this.active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`\r\n    )\r\n  }\r\n}\r\n","import { ReactiveEffect, trackOpBit } from './effect'\r\n\r\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\r\n\r\n/**\r\n * wasTracked and newTracked maintain the status for several levels of effect\r\n * tracking recursion. One bit per level is used to define whether the dependency\r\n * was/is tracked.\r\n */\r\ntype TrackedMarkers = {\r\n  /**\r\n   * wasTracked\r\n   */\r\n  w: number\r\n  /**\r\n   * newTracked\r\n   */\r\n  n: number\r\n}\r\n\r\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\r\n  const dep = new Set<ReactiveEffect>(effects) as Dep\r\n  dep.w = 0\r\n  dep.n = 0\r\n  return dep\r\n}\r\n\r\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\r\n\r\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\r\n\r\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].w |= trackOpBit // set was tracked\r\n    }\r\n  }\r\n}\r\n\r\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    let ptr = 0\r\n    for (let i = 0; i < deps.length; i++) {\r\n      const dep = deps[i]\r\n      if (wasTracked(dep) && !newTracked(dep)) {\r\n        dep.delete(effect)\r\n      } else {\r\n        deps[ptr++] = dep\r\n      }\r\n      // clear bits\r\n      dep.w &= ~trackOpBit\r\n      dep.n &= ~trackOpBit\r\n    }\r\n    deps.length = ptr\r\n  }\r\n}\r\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { extend, isArray, isIntegerKey, isMap } from '@vue/shared'\r\nimport { EffectScope, recordEffectScope } from './effectScope'\r\nimport {\r\n  createDep,\r\n  Dep,\r\n  finalizeDepMarkers,\r\n  initDepMarkers,\r\n  newTracked,\r\n  wasTracked\r\n} from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Sets to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<any, KeyToDepMap>()\r\n\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0\r\n\r\nexport let trackOpBit = 1\r\n\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = []\r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  private deferStop?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: EffectScheduler | null = null,\r\n    scope?: EffectScope\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  run() {\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let parent: ReactiveEffect | undefined = activeEffect\r\n    let lastShouldTrack = shouldTrack\r\n    while (parent) {\r\n      if (parent === this) {\r\n        return\r\n      }\r\n      parent = parent.parent\r\n    }\r\n    try {\r\n      this.parent = activeEffect\r\n      activeEffect = this\r\n      shouldTrack = true\r\n\r\n      trackOpBit = 1 << ++effectTrackDepth\r\n\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        initDepMarkers(this)\r\n      } else {\r\n        cleanupEffect(this)\r\n      }\r\n      return this.fn()\r\n    } finally {\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        finalizeDepMarkers(this)\r\n      }\r\n\r\n      trackOpBit = 1 << --effectTrackDepth\r\n\r\n      activeEffect = this.parent\r\n      shouldTrack = lastShouldTrack\r\n      this.parent = undefined\r\n\r\n      if (this.deferStop) {\r\n        this.stop()\r\n      }\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    // stopped while running itself - defer the cleanup\r\n    if (activeEffect === this) {\r\n      this.deferStop = true\r\n    } else if (this.active) {\r\n      cleanupEffect(this)\r\n      if (this.onStop) {\r\n        this.onStop()\r\n      }\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn)\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nconst trackStack: boolean[] = []\r\n\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep()))\r\n    }\r\n\r\n    const eventInfo = __DEV__\r\n      ? { effect: activeEffect, target, type, key }\r\n      : undefined\r\n\r\n    trackEffects(dep, eventInfo)\r\n  }\r\n}\r\n\r\nexport function trackEffects(\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  let shouldTrack = false\r\n  if (effectTrackDepth <= maxMarkerBits) {\r\n    if (!newTracked(dep)) {\r\n      dep.n |= trackOpBit // set newly tracked\r\n      shouldTrack = !wasTracked(dep)\r\n    }\r\n  } else {\r\n    // Full cleanup mode.\r\n    shouldTrack = !dep.has(activeEffect!)\r\n  }\r\n\r\n  if (shouldTrack) {\r\n    dep.add(activeEffect!)\r\n    activeEffect!.deps.push(dep)\r\n    if (__DEV__ && activeEffect!.onTrack) {\r\n      activeEffect!.onTrack({\r\n        effect: activeEffect!,\r\n        ...debuggerEventExtraInfo!\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || key >= (newValue as number)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  const eventInfo = __DEV__\r\n    ? { target, type, key, newValue, oldValue, oldTarget }\r\n    : undefined\r\n\r\n  if (deps.length === 1) {\r\n    if (deps[0]) {\r\n      if (__DEV__) {\r\n        triggerEffects(deps[0], eventInfo)\r\n      } else {\r\n        triggerEffects(deps[0])\r\n      }\r\n    }\r\n  } else {\r\n    const effects: ReactiveEffect[] = []\r\n    for (const dep of deps) {\r\n      if (dep) {\r\n        effects.push(...dep)\r\n      }\r\n    }\r\n    if (__DEV__) {\r\n      triggerEffects(createDep(effects), eventInfo)\r\n    } else {\r\n      triggerEffects(createDep(effects))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerEffects(\r\n  dep: Dep | ReactiveEffect[],\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  // spread into array for stabilization\r\n  const effects = isArray(dep) ? dep : [...dep]\r\n  for (const effect of effects) {\r\n    if (effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n  for (const effect of effects) {\r\n    if (!effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerEffect(\r\n  effect: ReactiveEffect,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  if (effect !== activeEffect || effect.allowRecurse) {\r\n    if (__DEV__ && effect.onTrigger) {\r\n      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\r\n    }\r\n    if (effect.scheduler) {\r\n      effect.scheduler()\r\n    } else {\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\n","import {\r\n  reactive,\r\n  readonly,\r\n  toRaw,\r\n  ReactiveFlags,\r\n  Target,\r\n  readonlyMap,\r\n  reactiveMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  isReadonly,\r\n  isShallow\r\n} from './reactive'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport {\r\n  track,\r\n  trigger,\r\n  ITERATE_KEY,\r\n  pauseTracking,\r\n  resetTracking\r\n} from './effect'\r\nimport {\r\n  isObject,\r\n  hasOwn,\r\n  isSymbol,\r\n  hasChanged,\r\n  isArray,\r\n  isIntegerKey,\r\n  extend,\r\n  makeMap\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol)\r\n)\r\n\r\nconst get = /*#__PURE__*/ createGetter()\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: Target, key: string | symbol, receiver: object) {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver ===\r\n        (isReadonly\r\n          ? shallow\r\n            ? shallowReadonlyMap\r\n            : readonlyMap\r\n          : shallow\r\n          ? shallowReactiveMap\r\n          : reactiveMap\r\n        ).get(target)\r\n    ) {\r\n      return target\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n      return Reflect.get(arrayInstrumentations, key, receiver)\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nconst set = /*#__PURE__*/ createSetter()\r\nconst shallowSet = /*#__PURE__*/ createSetter(true)\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\r\n      return false\r\n    }\r\n    if (!shallow && !isReadonly(value)) {\r\n      if (!isShallow(value)) {\r\n        value = toRaw(value)\r\n        oldValue = toRaw(oldValue)\r\n      }\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        oldValue.value = value\r\n        return true\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\nfunction deleteProperty(target: object, key: string | symbol): boolean {\r\n  const hadKey = hasOwn(target, key)\r\n  const oldValue = (target as any)[key]\r\n  const result = Reflect.deleteProperty(target, key)\r\n  if (result && hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction has(target: object, key: string | symbol): boolean {\r\n  const result = Reflect.has(target, key)\r\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction ownKeys(target: object): (string | symbol)[] {\r\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\r\n  return Reflect.ownKeys(target)\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n  deleteProperty,\r\n  has,\r\n  ownKeys\r\n}\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet,\r\n  set(target, key) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  },\r\n  deleteProperty(target, key) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  mutableHandlers,\r\n  {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n  }\r\n)\r\n\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  readonlyHandlers,\r\n  {\r\n    get: shallowReadonlyGet\r\n  }\r\n)\r\n","import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\r\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\r\n\r\nexport type CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (key !== rawKey) {\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (key !== rawKey) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this)\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE ? false : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false)\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true)\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n    ? readonlyInstrumentations\r\n    : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`\r\n    )\r\n  }\r\n}\r\n","import { isObject, toRawType, def } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers\r\n} from './collectionHandlers'\r\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nconst enum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Creates a reactive copy of the original object.\r\n *\r\n * The reactive conversion is \"deep\"—it affects all nested properties. In the\r\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\r\n * original object. It is recommended to work exclusively with the reactive\r\n * proxy and avoid relying on the original object.\r\n *\r\n * A reactive object also automatically unwraps refs contained in it, so you\r\n * don't need to use `.value` when accessing and mutating their value:\r\n *\r\n * ```js\r\n * const count = ref(0)\r\n * const obj = reactive({\r\n *   count\r\n * })\r\n *\r\n * obj.count++\r\n * obj.count // -> 1\r\n * count.value // -> 1\r\n * ```\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends ReadonlyMap<infer K, infer V>\r\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends WeakMap<infer K, infer V>\r\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n  : T extends Set<infer U>\r\n  ? ReadonlySet<DeepReadonly<U>>\r\n  : T extends ReadonlySet<infer U>\r\n  ? ReadonlySet<DeepReadonly<U>>\r\n  : T extends WeakSet<infer U>\r\n  ? WeakSet<DeepReadonly<U>>\r\n  : T extends Promise<infer U>\r\n  ? Promise<DeepReadonly<U>>\r\n  : T extends Ref<infer U>\r\n  ? Readonly<Ref<DeepReadonly<U>>>\r\n  : T extends {}\r\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n  : Readonly<T>\r\n\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap\r\n  )\r\n}\r\n\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>\r\n) {\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\r\n  )\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport function markRaw<T extends object>(\r\n  value: T\r\n): T & { [RawSymbol]?: true } {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value as Record<any, any>) : value\r\n","import {\r\n  activeEffect,\r\n  shouldTrack,\r\n  trackEffects,\r\n  triggerEffects\r\n} from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\r\nimport { isProxy, toRaw, isReactive, toReactive } from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { CollectionTypes } from './collectionHandlers'\r\nimport { createDep, Dep } from './dep'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    if (__DEV__) {\r\n      trackEffects(ref.dep || (ref.dep = createDep()), {\r\n        target: ref,\r\n        type: TrackOpTypes.GET,\r\n        key: 'value'\r\n      })\r\n    } else {\r\n      trackEffects(ref.dep || (ref.dep = createDep()))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\r\n  ref = toRaw(ref)\r\n  if (ref.dep) {\r\n    if (__DEV__) {\r\n      triggerEffects(ref.dep, {\r\n        target: ref,\r\n        type: TriggerOpTypes.SET,\r\n        key: 'value',\r\n        newValue: newVal\r\n      })\r\n    } else {\r\n      triggerEffects(ref.dep)\r\n    }\r\n  }\r\n}\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\nexport function ref<T extends object>(\r\n  value: T\r\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\nexport function shallowRef<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : ShallowRef<T>\r\nexport function shallowRef<T>(value: T): ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(value: T, public readonly __v_isShallow: boolean) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    newVal = this.__v_isShallow ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = this.__v_isShallow ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, newVal)\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport function unref<T>(ref: T | Ref<T>): T {\r\n  return isRef(ref) ? (ref.value as any) : ref\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  }\r\n}\r\n\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this)\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = toRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K]\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? (this._defaultValue as T[K]) : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): ToRef<T[K]>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K]\r\n): ToRef<Exclude<T[K], undefined>>\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue?: T[K]\r\n): ToRef<T[K]> {\r\n  const val = object[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Note that api-extractor somehow refuses to include `declare module`\r\n * augmentations in its generated d.ts, so we have to manually append them\r\n * to the final generated d.ts in our build process.\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: T[K] extends Ref<infer V>\r\n    ? V\r\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\r\n    T[K] extends Ref<infer V> | undefined\r\n    ? unknown extends V\r\n      ? undefined\r\n      : V | undefined\r\n    : T[K]\r\n}\r\n\r\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\r\n  ? V\r\n  : T extends Ref<infer V>\r\n  ? UnwrapRefSimple<V>\r\n  : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | CollectionTypes\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Array<any>\r\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n  : T extends object & { [ShallowReactiveMarker]?: never }\r\n  ? {\r\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n    }\r\n  : T\r\n","import { DebuggerOptions, ReactiveEffect } from './effect'\r\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { Dep } from './dep'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean\r\n\r\n  public _dirty = true\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean\r\n  ) {\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        triggerRefValue(this)\r\n      }\r\n    })\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    trackRefValue(self)\r\n    if (self._dirty || !self._cacheable) {\r\n      self._dirty = false\r\n      self._value = self.effect.run()!\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n}\r\n\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n","import { Dep } from './dep'\r\nimport { ReactiveEffect } from './effect'\r\nimport { ComputedGetter, ComputedRef } from './computed'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { trackRefValue, triggerRefValue } from './ref'\r\n\r\nconst tick = /*#__PURE__*/ Promise.resolve()\r\nconst queue: any[] = []\r\nlet queued = false\r\n\r\nconst scheduler = (fn: any) => {\r\n  queue.push(fn)\r\n  if (!queued) {\r\n    queued = true\r\n    tick.then(flush)\r\n  }\r\n}\r\n\r\nconst flush = () => {\r\n  for (let i = 0; i < queue.length; i++) {\r\n    queue[i]()\r\n  }\r\n  queue.length = 0\r\n  queued = false\r\n}\r\n\r\nclass DeferredComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  private _dirty = true\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY] = true\r\n\r\n  constructor(getter: ComputedGetter<T>) {\r\n    let compareTarget: any\r\n    let hasCompareTarget = false\r\n    let scheduled = false\r\n    this.effect = new ReactiveEffect(getter, (computedTrigger?: boolean) => {\r\n      if (this.dep) {\r\n        if (computedTrigger) {\r\n          compareTarget = this._value\r\n          hasCompareTarget = true\r\n        } else if (!scheduled) {\r\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value\r\n          scheduled = true\r\n          hasCompareTarget = false\r\n          scheduler(() => {\r\n            if (this.effect.active && this._get() !== valueToCompare) {\r\n              triggerRefValue(this)\r\n            }\r\n            scheduled = false\r\n          })\r\n        }\r\n        // chained upstream computeds are notified synchronously to ensure\r\n        // value invalidation in case of sync access; normal effects are\r\n        // deferred to be triggered in scheduler.\r\n        for (const e of this.dep) {\r\n          if (e.computed instanceof DeferredComputedRefImpl) {\r\n            e.scheduler!(true /* computedTrigger */)\r\n          }\r\n        }\r\n      }\r\n      this._dirty = true\r\n    })\r\n    this.effect.computed = this as any\r\n  }\r\n\r\n  private _get() {\r\n    if (this._dirty) {\r\n      this._dirty = false\r\n      return (this._value = this.effect.run()!)\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    return toRaw(this)._get()\r\n  }\r\n}\r\n\r\nexport function deferredComputed<T>(getter: () => T): ComputedRef<T> {\r\n  return new DeferredComputedRefImpl(getter) as any\r\n}\r\n"],"names":["get","has","set"],"mappings":"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"}